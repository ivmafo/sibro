package org.koghi.terranvm.entity;

// Generated 25-ene-2011 10:50:38 by Hibernate Tools 3.4.0.Beta1

import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.HashMap;
import java.util.HashSet;
import java.util.Hashtable;
import java.util.List;
import java.util.Set;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EntityManager;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.NamedQuery;
import javax.persistence.OneToMany;
import javax.persistence.OrderBy;
import javax.persistence.Query;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.Transient;

import org.hibernate.envers.Audited;
import org.hibernate.envers.NotAudited;
import org.hibernate.envers.RelationTargetAuditMode;
import org.hibernate.validator.NotNull;
import org.jboss.seam.core.ResourceBundle;

/**
 * ProjectProperty generated by hbm2java
 */
@Audited
@Entity
@NamedQuery(name = "projectProperty.availableTermSheets", query = "from ProjectProperty projectProperty WHERE projectProperty.status = ? AND ? >= projectProperty.obligationsStartDate AND ? <= projectProperty.expirationDate AND projectProperty.step = ?")
@Table(name = "project_property", schema = "public")
public class ProjectProperty implements java.io.Serializable {

	/**
	 * 
	 */
	private static final long serialVersionUID = -8052086855682600187L;
	public static final int STEP_approved_public_accountant = 0;
	public static final int STEP_pending_public_accountant_approval = 1;
	public static final short STATUS_DRAFT = 1;
	public static final short STATUS_APPROVED = 2;
	public static final short STATUS_TERMINATED = 3;
	public static final short STATUS_EXPIRED = 4;
	public static final Hashtable<Short, String> STATUS = new Hashtable<Short, String>();

	{
		STATUS.put(STATUS_DRAFT, "Borrador");
		STATUS.put(STATUS_APPROVED, "Aprobado");
		STATUS.put(STATUS_TERMINATED, "Terminacion anticipada");
		STATUS.put(STATUS_EXPIRED, "Vigencia vencida");
	}

	/**
	 * Constantes para manipular el tippo de periodo de la hoja de términos
	 */
	public static final String[][] PERIODS_TYPE = { { "1", "Días" }, { "2", "Meses" }, { "3", "Años" } };
	public static final int DAYS_PERIOD_TYPE = 1;
	public static final int MONTHS_PERIOD_TYPE = 2;
	public static final int YEARS_PERIOD_TYPE = 3;

	// Nombre de los atributos de la entidad para ser mostrado si se encuentra
	// cambios. Implementado para la funcionalidad de Novedades
	private static HashMap<String, String> fieldString = new HashMap<String, String>();
	// Variable para llenar la lista de los nombres de los atributos de la
	// entidad para ser mostrado si se encuentra cambios. Implementado para la
	// funcionalidad de Novedades
	private static boolean inisializationFieldList = false;

	// Atributos para el manejo del filtro de busqueda projectpropertylist
	private String billerName = "";
	private String billerNumberId = "";
	private String typeContract = "";
	private String billedName = "";
	// Atributos para el manejo del filtro de busqueda projectpropertylist

	private int id;
	private Integer version;
	private Address billerAddress;
	private BusinessEntity billed;
	private PhoneNumber phoneNumber;
	private Address billedAddress;
	private BusinessEntity biller;
	private BillingResolution billingResolution;
	private ContractType contractType;
	private Project project;
	private RealProperty realProperty;
	private Date subscriptionDate;
	private Date expirationDate;
	private short status;
	private Date startDateChanges;
	private String subjectContrat;
	private Date obligationsStartDate;
	private boolean isAutomaticExtension;
	private Integer periodicity;
	private Integer periodicityCopy;
	private Integer periodicityType;
	private RentableUnit rentableUnit;
	private String purpose;
	private ObjectOfContract objectOfContract;

	private boolean mandate;
	private Date noticeDate;
	private Integer numberPeriodsExtension = 0;
	private Integer periodicityExtension;
	private Integer periodicityTypeExtension;
	private ConsecutiveAccountsBilling acountsBilling;
	private ConsecutiveCreditNotes creditNotes;
	private List<Concept> concepts = new ArrayList<Concept>();
	private Set<Invoice> invoices = new HashSet<Invoice>(0);
	private int step;
	private PhoneNumber phoneNumberByPhoneBiller;
	private ConsecutiveCollectionAccount consecutiveCollectionAccount;
	private Integer consecutiveTermsSheet;
	private Set<PDFFile> files = new HashSet<PDFFile>(0);

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "creditnotes", nullable = true)
	@Audited(targetAuditMode = RelationTargetAuditMode.NOT_AUDITED)
	@NotAudited
	public ConsecutiveCreditNotes getCreditNotes() {
		return creditNotes;
	}

	public void setCreditNotes(ConsecutiveCreditNotes creditNotes) {
		this.creditNotes = creditNotes;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "acountsbilling", nullable = true)
	@Audited(targetAuditMode = RelationTargetAuditMode.NOT_AUDITED)
	@NotAudited
	public ConsecutiveAccountsBilling getAcountsBilling() {
		return acountsBilling;
	}

	public void setAcountsBilling(ConsecutiveAccountsBilling acountsBilling) {
		this.acountsBilling = acountsBilling;
	}

	public ProjectProperty() {
	}

	public ProjectProperty(int id) {
		this.id = id;
	}

	public ProjectProperty(int id, Address billerAddress, BusinessEntity billed, PhoneNumber phoneNumber, Address billedAddress, BusinessEntity biller, ContractType contractType, Project project, RealProperty realProperty, Date subscriptionDate, Date expirationDate, short status, String subjectContrat, Date obligationsStartDate, boolean isAutomaticExtension, ObjectOfContract objectOfContract, int step, boolean mandate, PhoneNumber phoneNumberByPhoneBiller) {
		this.id = id;
		this.billerAddress = billerAddress;
		this.billed = billed;
		this.phoneNumber = phoneNumber;
		this.billedAddress = billedAddress;
		this.biller = biller;
		this.contractType = contractType;
		this.project = project;
		this.realProperty = realProperty;
		this.subscriptionDate = subscriptionDate;
		this.expirationDate = expirationDate;
		this.status = status;
		this.subjectContrat = subjectContrat;
		this.obligationsStartDate = obligationsStartDate;
		this.isAutomaticExtension = isAutomaticExtension;
		this.objectOfContract = objectOfContract;
		System.out.println("***PSTEP**: " + this.step);
		this.step = step;
		this.mandate = mandate;
		this.phoneNumberByPhoneBiller = phoneNumberByPhoneBiller;
	}

	public ProjectProperty(int id, Address billerAddress, BusinessEntity billed, PhoneNumber phoneNumber, Address billedAddress, BusinessEntity biller, BillingResolution billingResolution, ContractType contractType, Project project, RealProperty realProperty, Date subscriptionDate, Date expirationDate, short status, Date startDateChanges, String subjectContrat, Date obligationsStartDate, boolean isAutomaticExtension, Integer periodicity, Integer periodicityType, RentableUnit rentableUnit, ObjectOfContract objectOfContract, String purpose, Set<Invoice> invoices, List<Concept> concepts, int step, boolean mandate, Date noticeDate, Integer numberPeriodsExtension, Integer periodicityExtension, Integer periodicityTypeExtension, ConsecutiveCollectionAccount consecutiveCollectionAccount,
			PhoneNumber phoneNumberByPhoneBiller, Integer consecutiveTermsSheet, Set<PDFFile> files) {
		this.id = id;
		this.biller = biller;
		this.billed = billed;
		this.phoneNumber = phoneNumber;
		this.billedAddress = billedAddress;
		this.biller = biller;
		this.billingResolution = billingResolution;
		this.contractType = contractType;
		this.project = project;
		this.realProperty = realProperty;
		this.subscriptionDate = subscriptionDate;
		this.expirationDate = expirationDate;
		this.status = status;
		this.startDateChanges = startDateChanges;
		this.subjectContrat = subjectContrat;
		this.obligationsStartDate = obligationsStartDate;
		this.isAutomaticExtension = isAutomaticExtension;
		this.periodicity = periodicity;
		this.periodicityCopy = periodicity;
		this.periodicityType = periodicityType;
		this.rentableUnit = rentableUnit;
		this.purpose = purpose;
		this.objectOfContract = objectOfContract;

		this.concepts = concepts;
		this.invoices = invoices;
		System.out.println("***PSTEP**: " + this.step);
		this.step = step;
		this.mandate = mandate;
		this.noticeDate = noticeDate;
		this.phoneNumberByPhoneBiller = phoneNumberByPhoneBiller;
		this.numberPeriodsExtension = numberPeriodsExtension;
		this.periodicityExtension = periodicityExtension;
		this.periodicityTypeExtension = periodicityTypeExtension;
		this.consecutiveCollectionAccount = consecutiveCollectionAccount;
		this.consecutiveTermsSheet = consecutiveTermsSheet;
		this.files = files;

	}

	@Id
	@Column(name = "id", unique = true, nullable = false)
	@SequenceGenerator(name = "pk_sequence", sequenceName = "project_property_id_seq", allocationSize = 1)
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "pk_sequence")
	public int getId() {
		return this.id;
	}

	public void setId(int id) {
		this.id = id;
	}

	@Column(name = "version")
	public Integer getVersion() {
		return this.version;
	}

	public void setVersion(Integer version) {
		this.version = version;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "address_biller", nullable = false)
	@NotNull
	@Audited(targetAuditMode = RelationTargetAuditMode.NOT_AUDITED)
	@NotAudited
	public Address getBillerAddress() {
		if(this.billerAddress == null && this.biller != null && this.biller.getAddresses() != null && this.biller.getAddresses().size() > 0 ){
			this.billerAddress = (Address) this.biller.getAddresses().toArray()[0];
		}
		return this.billerAddress;
	}

	public void setBillerAddress(Address billerAddress) {
		this.billerAddress = billerAddress;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "billed")
	@Audited(targetAuditMode = RelationTargetAuditMode.NOT_AUDITED)
	@NotAudited
	public BusinessEntity getBilled() {
		return this.billed;
	}

	public void setBilled(BusinessEntity billed) {
		this.billed = billed;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "phone_billed")
	public PhoneNumber getPhoneNumber() {
		if(this.phoneNumber == null && this.billed != null && this.billed.getPhoneNumbers() != null && this.billed.getPhoneNumbers().size() > 0 ){
			this.phoneNumber = (PhoneNumber) this.billed.getPhoneNumbers().toArray()[0];
		}
		return this.phoneNumber;
	}

	public void setPhoneNumber(PhoneNumber phoneNumber) {
		this.phoneNumber = phoneNumber;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "address_billed")
	@Audited(targetAuditMode = RelationTargetAuditMode.NOT_AUDITED)
	@NotAudited
	public Address getBilledAddress() {
		if(this.billedAddress == null && this.billed != null && this.billed.getAddresses() != null && this.billed.getAddresses().size() > 0 ){
			this.billedAddress = (Address) this.billed.getAddresses().toArray()[0];
		}
		return this.billedAddress;
	}

	public void setBilledAddress(Address billedAddress) {
		this.billedAddress = billedAddress;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "biller", nullable = false)
	@NotNull
	@Audited(targetAuditMode = RelationTargetAuditMode.NOT_AUDITED)
	@NotAudited
	public BusinessEntity getBiller() {
		return this.biller;
	}

	public void setBiller(BusinessEntity biller) {
		this.biller = biller;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "billing_resolution")
	public BillingResolution getBillingResolution() {
		return this.billingResolution;
	}

	public void setBillingResolution(BillingResolution billingResolution) {
		this.billingResolution = billingResolution;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "contract_type", nullable = false)
	@NotNull
	public ContractType getContractType() {
		return this.contractType;
	}

	public void setContractType(ContractType contractType) {
		this.contractType = contractType;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "project", nullable = false)
	@NotNull
	public Project getProject() {
		return this.project;
	}

	public void setProject(Project project) {
		this.project = project;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "real_property")
	public RealProperty getRealProperty() {
		return this.realProperty;
	}

	public void setRealProperty(RealProperty realProperty) {
		this.realProperty = realProperty;
	}

	@Temporal(TemporalType.DATE)
	@Column(name = "subscription_date", nullable = false, length = 13)
	@NotNull
	public Date getSubscriptionDate() {
		return this.subscriptionDate;
	}

	public void setSubscriptionDate(Date subscriptionDate) {
		this.subscriptionDate = subscriptionDate;
	}

	@Temporal(TemporalType.DATE)
	@Column(name = "expiration_date", nullable = false, length = 13)
	@NotNull
	public Date getExpirationDate() {
		return this.expirationDate;
	}

	public void setExpirationDate(Date expirationDate) {
		this.expirationDate = expirationDate;
	}

	@Column(name = "status", nullable = false)
	public short getStatus() {
		return this.status;
	}

	public void setStatus(short status) {
		this.status = status;
	}

	@Column(name = "purpose")
	public String getPurpose() {
		return this.purpose;
	}

	public void setPurpose(String purpose) {
		this.purpose = purpose;
	}

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "projectProperty", cascade = CascadeType.ALL)
	@OrderBy("lastModification")
	public List<Concept> getConcepts() {
		return this.concepts;
	}

	public void setConcepts(List<Concept> concepts) {
		this.concepts = concepts;
	}

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "projectProperty")
	@Audited(targetAuditMode = RelationTargetAuditMode.NOT_AUDITED)
	@NotAudited
	public Set<Invoice> getInvoices() {
		return this.invoices;
	}

	public void setInvoices(Set<Invoice> invoices) {
		this.invoices = invoices;
	}

	@Temporal(TemporalType.DATE)
	@Column(name = "start_date_changes", length = 13)
	public Date getStartDateChanges() {
		return this.startDateChanges;
	}

	public void setStartDateChanges(Date startDateChanges) {
		this.startDateChanges = startDateChanges;
	}

	@Column(name = "subject_contrat")
	public String getSubjectContrat() {
		return this.subjectContrat;
	}

	public void setSubjectContrat(String subjectContrat) {
		this.subjectContrat = subjectContrat;
	}

	@Temporal(TemporalType.DATE)
	@Column(name = "obligations_start_date", nullable = false, length = 13)
	@NotNull
	public Date getObligationsStartDate() {
		return this.obligationsStartDate;
	}

	public void setObligationsStartDate(Date obligationsStartDate) {
		this.obligationsStartDate = obligationsStartDate;
	}

	@Column(name = "is_automatic_extension", nullable = false)
	public boolean isAutomaticExtension() {
		return isAutomaticExtension;
	}

	public void setAutomaticExtension(boolean isAutomaticExtension) {
		this.isAutomaticExtension = isAutomaticExtension;
	}

	@Column(name = "periodicity_type", nullable = false)
	public Integer getPeriodicityType() {
		return this.periodicityType;
	}

	public void setPeriodicityType(Integer periodicityType) {
		this.periodicityType = periodicityType;
	}

	@Column(name = "periodicity", nullable = false)
	@NotNull
	public Integer getPeriodicity() {
		return this.periodicity;
	}

	public void setPeriodicity(Integer periodicity) {
		this.periodicity = periodicity;
		this.periodicityCopy = periodicity;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "rentable_unit")
	@Audited(targetAuditMode = RelationTargetAuditMode.NOT_AUDITED)
	@NotAudited
	public RentableUnit getRentableUnit() {
		return this.rentableUnit;
	}

	public void setRentableUnit(RentableUnit rentableUnit) {
		this.rentableUnit = rentableUnit;
	}

	@Column(name = "periodicity_copy", nullable = false)
	@NotNull
	public Integer getPeriodicityCopy() {
		return periodicityCopy;
	}

	public void setPeriodicityCopy(Integer periodicityCopy) {
		this.periodicityCopy = periodicityCopy;
	}

	@Column(name = "step", nullable = false)
	@NotNull
	public int getStep() {
		return step;
	}

	public void setStep(int step) {
		this.step = step;
	}

	@Temporal(TemporalType.DATE)
	@Column(name = "notice_date", length = 13)
	public Date getNoticeDate() {
		return this.noticeDate;
	}

	public void setNoticeDate(Date noticeDate) {
		this.noticeDate = noticeDate;
	}

	public boolean bandera = true;

	/**
	 * Booleano que indica si la hoja de terminos es por mandato. Esto quiere
	 * decir que cuando la hoja de terminos es por mandato (TRUE) el MANDANTE es
	 * el tercero asociado al proyecto de la hoja de terminos y el FACTURADOR es
	 * el tercero asociado a la Linea de Negocio que esta asociado al Proyecto
	 * de la Hoja de Terminos. Cuando la hoja de terminos no es por mandato, el
	 * FACTURADOR simplemente es el tercero que está asociado al proyecto de la
	 * hoja de terminos.
	 * 
	 * @author dvaldivieso
	 * @since 2012-12-04
	 * @return true si la hoja de terminos es por mandato, de lo contrario
	 *         false.
	 */
	@Column(name = "mandate", nullable = false)
	public boolean isMandate() {
		return this.mandate;
	}

	public void setMandate(boolean mandate) {
		this.mandate = mandate;
		this.bandera = this.mandate;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "object", nullable = false)
	@NotNull
	public ObjectOfContract getObjectOfContract() {
		return this.objectOfContract;
	}

	public void setObjectOfContract(ObjectOfContract objectOfContract) {
		this.objectOfContract = objectOfContract;
	}

	@Column(name = "number_periods_extension")
	public Integer getNumberPeriodsExtension() {
		return this.numberPeriodsExtension;
	}

	public void setNumberPeriodsExtension(Integer numberPeriodsExtension) {
		this.numberPeriodsExtension = numberPeriodsExtension;
	}

	@Column(name = "periodicity_extension")
	public Integer getPeriodicityExtension() {
		return this.periodicityExtension;
	}

	public void setPeriodicityExtension(Integer periodicityExtension) {
		this.periodicityExtension = periodicityExtension;
	}

	@Column(name = "periodicity_type_extension")
	public Integer getPeriodicityTypeExtension() {
		return this.periodicityTypeExtension;
	}

	public void setPeriodicityTypeExtension(Integer periodicityTypeExtension) {
		this.periodicityTypeExtension = periodicityTypeExtension;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "collection_accounts")
	@Audited(targetAuditMode = RelationTargetAuditMode.NOT_AUDITED)
	@NotAudited
	public ConsecutiveCollectionAccount getConsecutiveCollectionAccount() {
		return this.consecutiveCollectionAccount;
	}

	public void setConsecutiveCollectionAccount(ConsecutiveCollectionAccount consecutiveCollectionAccount) {
		this.consecutiveCollectionAccount = consecutiveCollectionAccount;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "phone_biller", nullable = false)
	@NotNull
	public PhoneNumber getPhoneNumberByPhoneBiller() {
		if(this.phoneNumberByPhoneBiller == null && this.biller != null && this.biller.getPhoneNumbers() != null && this.biller.getPhoneNumbers().size() > 0 ){
			this.phoneNumberByPhoneBiller = (PhoneNumber) this.biller.getPhoneNumbers().toArray()[0];
		}
		return this.phoneNumberByPhoneBiller;
	}

	public void setPhoneNumberByPhoneBiller(PhoneNumber phoneNumberByPhoneBiller) {
		this.phoneNumberByPhoneBiller = phoneNumberByPhoneBiller;
	}

	@Column(name = "consecutive_terms_sheet")
	public Integer getConsecutiveTermsSheet() {
		return this.consecutiveTermsSheet;
	}

	public void setConsecutiveTermsSheet(Integer consecutiveTermsSheet) {
		this.consecutiveTermsSheet = consecutiveTermsSheet;
	}

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "projectProperty", cascade = CascadeType.ALL)
	@Audited(targetAuditMode = RelationTargetAuditMode.NOT_AUDITED)
	@NotAudited
	public Set<PDFFile> getFiles() {
		return this.files;
	}

	public void setFiles(Set<PDFFile> files) {
		this.files = files;
	}

	@Transient
	public void updatePeriodicity(int periodicity) {
		this.periodicity = periodicity;
	}

	@Transient
	public void getEndDate() {
		Date endDate = null;
		if (this != null && this.getSubscriptionDate() != null && this.getPeriodicity() != null && this.getPeriodicityType() != null && this.getPeriodicityType() != 0) {

			endDate = calculateEndDate();
		}
		if (endDate != null) {
			setExpirationDate(endDate);
		}
	}

	@Transient
	public Date calculateEndDate() {
		Date endDate = null;

		if (this != null && this.getSubscriptionDate() != null && this.getPeriodicity() != null && this.getPeriodicityType() != null && this.getPeriodicityType() != 0) {

			Calendar calendar = Calendar.getInstance();
			calendar.setTime(this.getSubscriptionDate());

			switch (this.getPeriodicityType()) {
			case Concept.DAYS_PERIOD_TYPE:
				calendar.add(Calendar.DAY_OF_MONTH, this.getPeriodicity().intValue());
				break;

			case Concept.MONTHS_PERIOD_TYPE:
				calendar.add(Calendar.MONTH, this.getPeriodicity().intValue());
				break;
			case Concept.YEARS_PERIOD_TYPE:
				calendar.add(Calendar.YEAR, this.getPeriodicity().intValue());
				break;
			default:
				break;
			}
			calendar.add(Calendar.DAY_OF_MONTH, -1);
			endDate = calendar.getTime();
		}
		return endDate;
	}

	@Transient
	public static HashMap<String, String> getFieldString() {

		if (!inisializationFieldList) {
			fieldString.put("billerAddress", "Dirección del facturador");
			fieldString.put("billedAddress", "Dirección del facturado");
			fieldString.put("subscriptionDate", ResourceBundle.instance().getString("Subscription_date"));
			fieldString.put("expirationDate", ResourceBundle.instance().getString("Expiration_date"));
			fieldString.put("subscriptionDate", ResourceBundle.instance().getString("Subscription_date"));
			fieldString.put("status", ResourceBundle.instance().getString("Status"));
			fieldString.put("startDateChanges", ResourceBundle.instance().getString("Home_modifications"));
			fieldString.put("subjectContrat", ResourceBundle.instance().getString("Object_of_the_contract"));
			fieldString.put("obligationsStartDate", ResourceBundle.instance().getString("Date_of_commencement_of_duties"));
			fieldString.put("isAutomaticExtension", ResourceBundle.instance().getString("Automatic_extension"));
			fieldString.put("periodicity", ResourceBundle.instance().getString("periodicity"));
			fieldString.put("periodicityType", "Tipo de periodicidad");
			fieldString.put("purpose", "Destinación de la unidad arrendable");
		}

		return fieldString;
	}

	@Transient
	public void applyExtension() {

		Date endDate = null;
		if (this != null && this.getPeriodicityExtension() != null && this.getPeriodicityTypeExtension() != null && this.getPeriodicityTypeExtension() != 0 && this.getNumberPeriodsExtension() != null && this.getNumberPeriodsExtension() > 0) {

			Calendar calendar = Calendar.getInstance();
			calendar.set(Calendar.HOUR, 0);
			calendar.set(Calendar.MINUTE, 0);
			calendar.set(Calendar.SECOND, 0);
			calendar.set(Calendar.MILLISECOND, 0);
			calendar.set(Calendar.AM_PM, Calendar.AM);

			switch (this.getPeriodicityTypeExtension()) {
			case Concept.DAYS_PERIOD_TYPE:
				calendar.add(Calendar.DAY_OF_MONTH, (this.getPeriodicityExtension().intValue()));
				break;

			case Concept.MONTHS_PERIOD_TYPE:
				calendar.add(Calendar.MONTH, (this.getPeriodicityExtension().intValue()));
				break;
			case Concept.YEARS_PERIOD_TYPE:
				calendar.add(Calendar.YEAR, (this.getPeriodicityExtension().intValue()));
				break;
			default:
				break;
			}
			endDate = calendar.getTime();
			setExpirationDate(endDate);
			setNumberPeriodsExtension(getNumberPeriodsExtension() - 1);
		}

	}

	/**
	 * Método que retorna los valores del concepto, que se calcularon para un
	 * periodo determinado.
	 * 
	 * @param date
	 *            : Fecha en que se necesita con que valor de calculo el
	 *            concepto
	 */
	@Transient
	public String calculatedConcepts(Calendar date, EntityManager entityManager) {
		/**
		 * Se crea arreglo de Concepts
		 */
		String conceptString = "var CONCEPT = new Array(); ";
		/**
		 * Se Realiza consulta que trae los invoiceConcept de los conceptos
		 * asociados a la hoja de termino que sean no dependientes y que los
		 * invoice_concept esten calculados en ese periodo.
		 */
		String sql = "SELECT iv.id, iv.calculated_cost FROM invoice_concept iv where iv.concept in (select id from concept where project_property = ?) and iv.concept in (select id from concept where dependent = ?) and (? between ini_period_date and end_period_date)";

		Query query = entityManager.createNativeQuery(sql);
		query.setParameter(1, this.getId());
		query.setParameter(2, false);
		query.setParameter(3, date.getTime());
		List<?> invoiceConceptList = query.getResultList();

		for (int i = 0; i < invoiceConceptList.size(); i++) {
			Object[] invoiceConcept = (Object[]) invoiceConceptList.get(i);
			conceptString += "CONCEPT[" + invoiceConcept[0] + "] = " + invoiceConcept[1] + "; ";
		}
		return conceptString;
	}

	// Atributos para el manejo del filtro de busqueda projectpropertylist

	@Transient
	public String getBillerName() {
		return billerName;
	}

	public void setBillerName(String billerName) {
		this.billerName = billerName;
	}

	@Transient
	public String getBillerNumberId() {
		return billerNumberId;
	}

	public void setBillerNumberId(String billerNumberId) {
		this.billerNumberId = billerNumberId;
	}

	@Transient
	public String getTypeContract() {
		return typeContract;
	}

	public void setTypeContract(String typeContract) {
		this.typeContract = typeContract;
	}

	@Transient
	public String getBilledName() {
		return billedName;
	}

	public void setBilledName(String BilledName) {
		this.billedName = BilledName;
	}
}
