package org.koghi.terranvm.entity;

// Generated 24-ene-2011 9:16:15 by Hibernate Tools 3.4.0.Beta1 DAVID

import java.text.DecimalFormat;
import java.util.ArrayList;
import java.util.Calendar;
import java.util.Date;
import java.util.List;
import java.util.logging.Level;
import java.util.logging.Logger;

import javax.persistence.CascadeType;
import javax.persistence.Column;
import javax.persistence.Entity;
import javax.persistence.EntityManager;
import javax.persistence.FetchType;
import javax.persistence.GeneratedValue;
import javax.persistence.GenerationType;
import javax.persistence.Id;
import javax.persistence.JoinColumn;
import javax.persistence.ManyToOne;
import javax.persistence.OneToMany;
import javax.persistence.SequenceGenerator;
import javax.persistence.Table;
import javax.persistence.Temporal;
import javax.persistence.TemporalType;
import javax.persistence.Transient;
import javax.script.ScriptEngine;
import javax.script.ScriptEngineManager;
import javax.script.ScriptException;

import org.hibernate.envers.Audited;
import org.hibernate.envers.NotAudited;
import org.hibernate.envers.RelationTargetAuditMode;
import org.hibernate.validator.Length;
import org.hibernate.validator.NotNull;

/**
 * Concept generated by hbm2java
 */
@Audited
@Entity
@Table(name = "concept", schema = "public")
public class Concept implements java.io.Serializable {

	/**
	 * 
	 */
	private static final long serialVersionUID = 5729256531841854162L;
	public static final String[][] PERIODS_TYPE = { { "1", "Días" }, { "2", "Meses" }, { "3", "Años" } };
	public static final int DAYS_PERIOD_TYPE = 1;
	public static final int MONTHS_PERIOD_TYPE = 2;
	public static final int YEARS_PERIOD_TYPE = 3;

	/**
	 * Variables que le indican al concepto de donde viene el centro de COSTO
	 */
	public static final int COST_CENTER_TYPE_PROJECT = 1;
	public static final int COST_CENTER_TYPE_RENTABLEUNIT = 2;
	public static final int COST_CENTER_TYPE_CONCEPT = 3;
	public static final String[][] COST_CENTER_TYPES = { { COST_CENTER_TYPE_PROJECT + "", "Proyecto" }, { COST_CENTER_TYPE_RENTABLEUNIT + "", "Unidad Arrendable" }, { COST_CENTER_TYPE_CONCEPT + "", "Concepto" } };

	/**
	 * Variable para determinar responsable RESPONSAIBLE_LESSEE: Responsable
	 * arrendatario RESPONSAIBLE_OWNER: Responsable propietario
	 */
	public static final int RESPONSAIBLE_LESSEE = 0;
	public static final int RESPONSAIBLE_OWNER = 1;

	public static final String[][] PRIORITYS = { { "1", "Baja" }, { "2", "Media" }, { "3", "Media Alta" }, { "4", "Alta" }, { "5", "Muy Alta" } };
	public static final int PRIORITY_LOWER = 1;
	public static final int PRIORITY_MEDIA = 2;
	public static final int PRIORITY_MEDIA_HIGHT = 3;
	public static final int PRIORITY_HIGHT = 4;
	public static final int PRIORITY_VERY_HIGHT = 5;

	public static final int IMMEDIATE_PAYMENT_NOT_SET = 0;
	public static final int IMMEDIATE_PAYMENT_SET_WITHOUT_CHARGE = 1;
	public static final int IMMEDIATE_PAYMENT_SET_ALREADY_CHARGED = 2;

	// Tipo de dofumento Fáctura
	public static final int DOCUMENT_TYPE_BILL = 0;
	// Tipo de dofumento Cuenta de cobro
	public static final int DOCUMENT_TYPE_ACCOUNT_RECEIVABLE = 1;
	// TIPOS DE DOCUMENTO SI ES 0 ES FACTURA(F) SI ES 1 CUANTA DE COBRO(L) Y SI
	// ES 2 NOTA CRÉDITO(N)
	public static final String[][] DOCUMENT_TYPES = { { "0", "F" }, { "1", "L" }, { "2", "N" } };

	private int id;
	private ProjectProperty projectProperty;

	private String name;
	private Long periodicity;
	private Integer periodicityType;
	private Integer discountDays;
	private Integer documentType = 0;
	private Double promptPaymentDiscount;
	private Integer responsible = 0;
	private Date startDate;
	private Integer numberPeriods;
	private boolean isEarlyPayment = true;
	private String printDescription;
	private int groupNumber = 0;
	private String expression;
	private ContributionModule contributionModule;
	private int priority;
	private Date lastModification;
	private Integer discountMounths = 0;

	private Double fixedValue;
	private Increased increased;
	private boolean seed;
	private boolean interestArrears;
	private boolean dependent;
	private List<InvoiceConcept> invoiceConcepts = new ArrayList<InvoiceConcept>();
	private List<ConceptRetentionRateAccount> conceptRetentionRateAccounts = new ArrayList<ConceptRetentionRateAccount>();
	private String costCenter;
	private int costCenterType;
	private boolean automaticExtension;
	private int immediatePaymentState;
	public static List<ConceptRetentionRateAccount> RetentionToDelete = new ArrayList<ConceptRetentionRateAccount>();

	private boolean showBilledPeriod = true;
	private boolean bulkLoad;

	public Concept() {
	}

	public Concept(int id, ProjectProperty projectProperty, String printDescription, boolean isEarlyPayment, int priority, boolean interestArrears, boolean automaticExtension, int immediatePaymentState) {
		this.id = id;
		this.projectProperty = projectProperty;

		this.printDescription = printDescription;
		this.isEarlyPayment = isEarlyPayment;
		this.priority = priority;
		this.interestArrears = interestArrears;
		this.automaticExtension = automaticExtension;
		this.immediatePaymentState = immediatePaymentState;
		this.lastModification = Calendar.getInstance().getTime();
		this.showBilledPeriod = true;
		this.discountMounths = 0;
	}

	public Concept(int id, ProjectProperty projectProperty, String name, Long periodicity, Integer periodicityType, Integer discountDays, Integer documentType, Double promptPaymentDiscount, Integer responsible, Date startDate, String printDescription, List<InvoiceConcept> invoiceConcepts, boolean isEarlyPayment, String expression, int priority, List<ConceptRetentionRateAccount> conceptRetentionRateAccounts, Increased increased, Double fixedValue, boolean interestArrears, String costcenter, int costCenterType, boolean automaticExtension, int immediatePaymentState, boolean bulkName) {
		this.id = id;
		this.projectProperty = projectProperty;
		this.name = name;
		this.periodicity = periodicity;
		this.periodicityType = periodicityType;
		this.discountDays = discountDays;
		this.documentType = documentType;
		this.promptPaymentDiscount = promptPaymentDiscount;
		this.responsible = responsible;
		this.startDate = startDate;
		this.printDescription = printDescription;
		this.isEarlyPayment = isEarlyPayment;
		this.invoiceConcepts = invoiceConcepts;
		this.expression = expression;
		this.priority = priority;
		this.conceptRetentionRateAccounts = conceptRetentionRateAccounts;
		this.fixedValue = fixedValue;
		this.increased = increased;
		this.conceptRetentionRateAccounts = conceptRetentionRateAccounts;
		this.interestArrears = interestArrears;
		this.costCenter = costcenter;
		this.costCenterType = costCenterType;
		this.automaticExtension = automaticExtension;
		this.immediatePaymentState = immediatePaymentState;
		this.bulkLoad = bulkName;
		this.lastModification = Calendar.getInstance().getTime();
		this.showBilledPeriod = true;
		this.discountMounths = 0;
	}

	@Id
	@SequenceGenerator(name = "pk_sequence", sequenceName = "concept_id_seq", allocationSize = 1)
	@GeneratedValue(strategy = GenerationType.SEQUENCE, generator = "pk_sequence")
	@Column(name = "id", unique = true, nullable = false)
	public int getId() {
		return this.id;
	}

	public void setId(int id) {
		this.id = id;
	}

	@Transient
	public RetentionRateAccount getStamptax() {
		return searchAccount(RetentionRate.RETENTION_RATE_TIMBRE);
	}

	public void setStamptax(ConceptRetentionRateAccount Stamptax) {
		setAccount(RetentionRate.RETENTION_RATE_TIMBRE, Stamptax);
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "project_property", nullable = false)
	@NotNull
	public ProjectProperty getProjectProperty() {
		return this.projectProperty;
	}

	public void setProjectProperty(ProjectProperty projectProperty) {
		this.projectProperty = projectProperty;
	}

	@Transient
	public RetentionRateAccount getTax() {
		return searchAccount(RetentionRate.RETENTION_RATE_IVA);
	}

	public void setTax(ConceptRetentionRateAccount tax) {
		setAccount(RetentionRate.RETENTION_RATE_IVA, tax);
	}

	@Column(name = "name")
	public String getName() {
		return this.name;
	}

	public void setName(String name) {
		this.name = name;
	}

	@Column(name = "periodicity", nullable = false)
	@NotNull
	public Long getPeriodicity() {
		return this.periodicity;
	}

	public void setPeriodicity(Long periodicity) {
		this.periodicity = periodicity;
	}

	@Column(name = "periodicity_type", nullable = false)
	public Integer getPeriodicityType() {
		return this.periodicityType;
	}

	public void setPeriodicityType(Integer periodicityType) {
		this.periodicityType = periodicityType;
	}

	@Column(name = "discount_days")
	public Integer getDiscountDays() {
		return this.discountDays;
	}

	public void setDiscountDays(Integer discountDays) {
		this.discountDays = discountDays;
	}

	@Column(name = "document_type")
	public Integer getDocumentType() {
		return this.documentType;
	}

	public void setDocumentType(Integer documentType) {
		this.documentType = documentType;
	}

	@Column(name = "prompt_payment_discount", precision = 17, scale = 17)
	public Double getPromptPaymentDiscount() {
		return this.promptPaymentDiscount;
	}

	public void setPromptPaymentDiscount(Double promptPaymentDiscount) {
		this.promptPaymentDiscount = promptPaymentDiscount;
	}

	@Column(name = "responsible")
	public Integer getResponsible() {
		return this.responsible;
	}

	public void setResponsible(Integer responsible) {
		this.responsible = responsible;
	}

	@Temporal(TemporalType.DATE)
	@Column(name = "start_date", length = 13, nullable = false)
	@NotNull
	public Date getStartDate() {
		return this.startDate;
	}

	public void setStartDate(Date startDate) {
		this.startDate = startDate;
	}

	@ManyToOne(fetch = FetchType.LAZY, cascade = CascadeType.ALL)
	@JoinColumn(name = "increased")
	@Audited(targetAuditMode = RelationTargetAuditMode.NOT_AUDITED)
	@NotAudited
	public Increased getIncreased() {
		return this.increased;
	}

	public void setIncreased(Increased increased) {
		this.increased = increased;
	}

	@Column(name = "fixed_value", precision = 17, scale = 17)
	public Double getFixedValue() {
		return this.fixedValue;
	}

	public void setFixedValue(Double fixedValue) {
		this.fixedValue = fixedValue;
	}

	@Column(name = "print_description")
	public String getPrintDescription() {
		return this.printDescription;
	}

	public void setPrintDescription(String printDescription) {
		this.printDescription = printDescription;
	}

	@Column(name = "number_periods", nullable = false)
	@NotNull
	public Integer getNumberPeriods() {
		return this.numberPeriods;
	}

	public void setNumberPeriods(Integer numberPeriods) {

		this.numberPeriods = numberPeriods;
	}

	@Column(name = "is_early_payment", nullable = false)
	public boolean isEarlyPayment() {
		return isEarlyPayment;
	}

	public void setEarlyPayment(boolean isEarlyPayment) {
		this.isEarlyPayment = isEarlyPayment;
	}

	@Column(name = "group_number", nullable = false)
	@NotNull
	public int getGroupNumber() {
		return groupNumber;
	}

	public void setGroupNumber(int groupNumber) {
		this.groupNumber = groupNumber;
	}

	/**
	 * Método privado que ejecuta script de Rhyno para que el concepto calcule
	 * su valor.
	 * 
	 * @param ruc
	 *            RentableUnitContribution (porcentaje de contribution para
	 *            unidad arrendable)
	 * @param calculationDate
	 *            (Fecha de calculo)
	 * @param ipcYearly
	 *            (Array con IPCAnual)
	 * @param ipcMonthly
	 *            (Array ipc Mensual)
	 * @param ipcAccummalted
	 *            (Array ipc Acumulado)
	 * @param Expression
	 *            (Expresion de calculo . Ya sea la del concepto ó del
	 *            incremento)
	 * @return
	 */
	@Transient
	private Double executeScript(RentableUnitContribution ruc, Calendar calculationDate, String ipcYearly, String ipcMonthly, String ipcAccummalted, String expression, EntityManager entitymanger, String minimumWage) {
		if (minimumWage == null) {
			MinimunWage wage = new MinimunWage();
			minimumWage = wage.getMinimumWages(entitymanger);
		}

		/**
		 * Se Crea SCript
		 */
		ScriptEngineManager scriptManager = new ScriptEngineManager();
		ScriptEngine jsEngine = scriptManager.getEngineByName("js");
		/**
		 * Se agrega variable valor fijo, si es null se pone valor CERO
		 */
		jsEngine.put(String.valueOf("VFIJO"), ((this.fixedValue == null) ? 0 : this.fixedValue));
		/**
		 * Se agrega mes y año
		 */
		jsEngine.put(String.valueOf("YEAR"), calculationDate.get(Calendar.YEAR));
		// if(calculationDate.after(Calendar.getInstance().getTime()));
		// calculationDate.setTime(Calendar.getInstance().getTime());
		// int vtsmes=(calculationDate.get(Calendar.YEAR) * 12) +
		// (calculationDate.get(Calendar.MONTH));
		// jsEngine.put(String.valueOf("MONTH"), vtsmes);
		jsEngine.put(String.valueOf("MONTH"), (calculationDate.get(Calendar.YEAR) * 12) + (calculationDate.get(Calendar.MONTH)));
		/**
		 * Se agregan IPC'S a las formulas
		 */
		StringBuilder expressionCalculate = new StringBuilder();
		expressionCalculate.append(ipcYearly);
		expressionCalculate.append(ipcMonthly);
		expressionCalculate.append(ipcAccummalted);
		expressionCalculate.append(minimumWage);
		expressionCalculate.append(" MONTH = MONTH*1; YEAR = YEAR*1; ");
		/**
		 * Se agregar variables globales del Systema que estan relacionados al
		 * proyectos
		 */
		expressionCalculate.append(SystemVariable.getSystemVariableByProject(this.projectProperty.getProject()));

		/**
		 * Se verifica si el concepto a Ejecutar le asignaron un modulo de
		 * contribucion. En ese caso se asigna a las formulas las siguientes
		 * variables: 1)MC: Modulo de contribucion. En ese caso se pasa un
		 * objeto RentableUnitContribution el cual tiene el valor de un modulo
		 * de contribución para una unidad arrendable, En este caso aplica
		 * cuando la TS es de tipo activo (PH'S), en este caso se invoca este
		 * mismo concepto por la cantidad de unidades arrendables asociadas al
		 * modulo de contribución. 2)AREA: Areas de la unidad arrendable. se
		 * toma el valor del área arrendable de la unidad arrendable, esta
		 * unidad esta asociada al RentableUnitContribution. 3)VTAS: Ventas de
		 * la unidad arrendable.se toma el valor del área arrendable de la
		 * unidad arrendable, esta unidad esta asociada al
		 * RentableUnitContribution.
		 */
		if (ruc != null && ruc.getId() != 0) {
			jsEngine.put(String.valueOf("MC"), ruc.getContributionRate());
			/**
			 * Se agregar area a Unidad Arrendable. si el
			 * RentableUnitContribution tiene unidad arrendable Sd
			 * asigna:AREA*,VTAS
			 * 
			 */
			if (ruc.getRentableUnit() != null) {
				/**
				 * Se agregan todoas las areas de la distribución del Activo al
				 * cual pertenece el area arrendable
				 */
				jsEngine.put(String.valueOf("AREA"), ruc.getRentableUnit().getTotalRentableArea());
				jsEngine.put(String.valueOf("TPAREA"), ruc.getRentableUnit().getArea().getTotalRentableArea());
				jsEngine.put(String.valueOf("PIAREA"), ruc.getRentableUnit().getArea().getFloor().getTotalRentableArea());
				jsEngine.put(String.valueOf("EDFAREA"), ruc.getRentableUnit().getArea().getFloor().getConstruction().getTotalRentableArea());
				jsEngine.put(String.valueOf("RPAREA"), ruc.getRentableUnit().getArea().getFloor().getConstruction().getRealProperty().getTotalRentableArea());
				
				/*
				 * SE OBTIENEN VENTAS
				 */
				expressionCalculate.append(ruc.getRentableUnit().getSalesRentableUnit());
			}
		} else {
			/**
			 * Se verifica si la Hoja de Temrino tiene unidad arrendable. Para
			 * asignarle las variables : AREAS,VTAS. Se agregan todoas las areas
			 * de la distribución del Activo al cual pertenece el area
			 * arrendable
			 */

			if (this.projectProperty.getRentableUnit() != null) {
				jsEngine.put(String.valueOf("AREA"), this.projectProperty.getRentableUnit().getTotalRentableArea());
				jsEngine.put(String.valueOf("TPAREA"), this.projectProperty.getRentableUnit().getArea().getTotalRentableArea());
				jsEngine.put(String.valueOf("PIAREA"), this.projectProperty.getRentableUnit().getArea().getFloor().getTotalRentableArea());
				jsEngine.put(String.valueOf("EDFAREA"), this.projectProperty.getRentableUnit().getArea().getFloor().getConstruction().getTotalRentableArea());
				jsEngine.put(String.valueOf("RPAREA"), this.projectProperty.getRentableUnit().getArea().getFloor().getConstruction().getRealProperty().getTotalRentableArea());
				expressionCalculate.append(this.projectProperty.getRentableUnit().getSalesRentableUnit());
			} else {
				String salesString = "var VTAS = new Array(); ";

				Calendar currentDate = Calendar.getInstance();
				Integer periodMonthlyEnd = (currentDate.get(Calendar.YEAR) * 12) + (currentDate.get(Calendar.MONTH) + 1);

				currentDate.add(Calendar.YEAR, -2);
				Integer periodMonthlyStart = (currentDate.get(Calendar.YEAR) * 12) + (currentDate.get(Calendar.MONTH));

				for (Integer i = periodMonthlyStart; i <= periodMonthlyEnd; i++) {
					salesString += "VTAS [" + i + "] = 0.00; ";
				}

				expressionCalculate.append(salesString);
			}

			if (ruc != null) {
				jsEngine.put(String.valueOf("MC"), ruc.getContributionRate());
			}
		}
		/**
		 * Se veriifica si el concepto en no dependiente y viene el
		 * EntityManager, en este momento de ejecuta el metodo que trae el
		 * listado del calculo de cada concepto
		 */
		if (entitymanger != null) {

			expressionCalculate.append(this.projectProperty.calculatedConcepts(calculationDate, entitymanger));
		}
		/**
		 * Se agrega expression de calculo
		 */
		expressionCalculate.append(expression);
		/**
		 * Uhy!!!! Se Ejecuta Escript------
		 */
		try {
			log(Level.INFO, "EXPRESSION SCRIPT: " + expressionCalculate);
			Object result = jsEngine.eval(expressionCalculate.toString());
			Double calculated = null;
			if (result instanceof Double) {
				calculated = (Double) result;
			} else {
				/* No es string se tratara de convertir a double */
				try {
					calculated = Double.parseDouble((String) result);
				} catch (NumberFormatException ex) {
					log(Level.INFO, "1ERROR  CONCEPT SCRIPT: (Valor no es numero)" + String.valueOf(result) + "isn.of" + result.getClass());
					ex.printStackTrace();
					return null;
				}

			}
			/* Se verifica si el Valor es Double Valido */
			if (calculated.isNaN() || calculated.isInfinite()) {
				log(Level.INFO, "2ERROR  CONCEPT SCRIPT: (Valor no es numero)" + String.valueOf(result) + "isn.of" + result.getClass());
				return null;
			}
			return calculated;
		} catch (ScriptException e) {
			log(Level.INFO, "ERROR  CONCEPT SCRIPT: " + expressionCalculate);
			e.printStackTrace();
			return null;
		} catch (NullPointerException npex) {
			log(Level.INFO, "ERROR  CONCEPT SCRIPT: " + expressionCalculate);
			npex.printStackTrace();
			return null;
		} catch (Exception ex) {
			log(Level.INFO, "ERROR  CONCEPT SCRIPT: " + expressionCalculate);
			ex.printStackTrace();
			return null;
		}

	}

	/**
	 * Método que liquida el valor del concepto, de acuerdo a su Scripts
	 * configurado.
	 * 
	 * @param ruc
	 *            RentableUnitContribution (porcentaje de contribution para
	 *            unidad arrendable)
	 * @param calculationDate
	 *            (Fecha de calculo)
	 * @param sales
	 *            (Objet Ventas ** Deprecated **)
	 * @param ipcYearly
	 *            (Array con IPCAnual)
	 * @param ipcMonthly
	 *            (Array ipc Mensual)
	 * @param ipcAccummalted
	 *            (Array ipc Acumulado)
	 * @return
	 */
	@Transient
	public Double calculateValueConceptByPlugin(RentableUnitContribution ruc, Calendar calculationDate, String ipcYearly, String ipcMonthly, String ipcAccummalted, EntityManager entitymanager, String minimumWage) {

		return this.executeScript(ruc, calculationDate, ipcYearly, ipcMonthly, ipcAccummalted, this.expression, entitymanager, minimumWage);
	}

	/**
	 * Metodo que Calcula la fecha del proximo incremento de un concepto
	 * 
	 * @param increasedDate
	 *            fecha del incremento
	 * @param peridicityType
	 *            Tipo de periodicidad
	 * @param periodicty
	 *            periodicida
	 * @return
	 */
	@Transient
	private Calendar getNextIncreased(Calendar increasedDate, Integer peridicityType, Integer periodicty) {

		switch (peridicityType) {
		case Concept.DAYS_PERIOD_TYPE:
			increasedDate.add(Calendar.DAY_OF_MONTH, periodicty);
			break;
		case Concept.MONTHS_PERIOD_TYPE:
			increasedDate.add(Calendar.MONTH, periodicty);
			break;
		case Concept.YEARS_PERIOD_TYPE:
			increasedDate.add(Calendar.YEAR, periodicty);
			break;
		default:
			break;
		}

		return increasedDate;
	}

	/**
	 * Metodo que verifica si dos fechas (Dates yyy-MM-dd) coinciden
	 * 
	 * @param increasedDate
	 * @param calculationDate
	 * @return
	 */
	private boolean compareDate(Calendar increasedDate, Calendar calculationDate) {

		if (increasedDate.get(Calendar.YEAR) == calculationDate.get(Calendar.YEAR) && (increasedDate.get(Calendar.MONTH)) == calculationDate.get(Calendar.MONTH) && increasedDate.get(Calendar.DAY_OF_MONTH) == calculationDate.get(Calendar.DAY_OF_MONTH)) {
			return true;
		}

		return false;
	}

	/**
	 * Método que liquida el valor del concepto, de acuerdo a su Scripts
	 * configurado.
	 * 
	 * @param ruc
	 *            RentableUnitContribution (porcentaje de contribution para
	 *            unidad arrendable)
	 * @param calculationDate
	 *            (Fecha de calculo)
	 * @param sales
	 *            (Object Ventas ****DEPRECATED***)
	 * @param ipcYearly
	 *            (Array con IPCAnual)
	 * @param ipcMonthly
	 *            (Array ipc Mensual)
	 * @param ipcAccummalted
	 *            (Array ipc Acumulado)
	 */
	@Transient
	public Boolean calculateValueIncreisedConcept(String ipcYearly, String ipcMonthly, Calendar calculationDate, RentableUnitContribution ruc, String ipcAccummalted, String minimumWage) {
		/**
		 * Se valida si el Concepto tiene incremento
		 */
		if (this.increased != null) {

			
			Calendar increasedDate = Calendar.getInstance();
			increasedDate.setTime(this.increased.getNextIncreased());

			Calendar lastCalculated = Calendar.getInstance();
			if (this.increased.getLastCalculated() == null) {
				Calendar date = Calendar.getInstance();
				date.add(Calendar.DATE, -1);
				lastCalculated.setTime(date.getTime());
			} else {
				lastCalculated.setTime(this.increased.getLastCalculated());
			}

			/**
			 * Se verifica si el concepto se le debe aplicar Incremento
			 */
			log(Level.INFO, "***********VERIFICANDO SI APLICA INCREMENTO***************:" + increasedDate.getTime() + " Cl: " + calculationDate.getTime());
			// if (this.compareDate(increasedDate, calculationDate)) {
			/***
			 * Se verifica si el Incremento ya se le aplico el incremento, en la
			 * ejecucion del CronJob
			 */
			// if (this.compareDate(lastCalculated, calculationDate))
			log(Level.INFO, "***********EJECUTANO INCREMENTO**************************");

			try {
				/**
				 * Se ejecuta incremento
				 */
				Double increasedValue = this.executeScript(ruc, calculationDate, ipcYearly, ipcMonthly, ipcAccummalted, this.getIncreased().getExpression(), null, minimumWage);
				/**
				 * Se actualiza el concepto con el cambio del valor base y el
				 * incremento
				 */
				if (this.compareDate(increasedDate, calculationDate)) {
					/**
					 * Se actualiza Fecha del proximo incremento
					 */
					Calendar nexIncrement = this.getNextIncreased(increasedDate, this.getIncreased().getPeriodicityType(), this.getIncreased().getPeriodicity());

					this.getIncreased().setNextIncreased(nexIncrement.getTime());
					this.getIncreased().setLastCalculated(calculationDate.getTime());
				}
				this.setFixedValue(increasedValue);
				log(Level.INFO, "NUEVO VALOR INCREMENTO: " + this.getFixedValue());

			} catch (NullPointerException npex) {
				log(Level.INFO, "ERROR  EJECUTANDO INCREMENTO DEL CONCEPT : " + this.getId() + " HT: " + this.getProjectProperty().getId());
				npex.printStackTrace();
				return false;
			}
			// }
		}
		return true;
	}

	/**
	 * Método que retorna el valor del incremento
	 * configurado.
	 * 
	 * @param ruc
	 *            RentableUnitContribution (porcentaje de contribution para
	 *            unidad arrendable)
	 * @param calculationDate
	 *            (Fecha de calculo)
	 * @param sales
	 *            (Object Ventas ****DEPRECATED***)
	 * @param ipcYearly
	 *            (Array con IPCAnual)
	 * @param ipcMonthly
	 *            (Array ipc Mensual)
	 * @param ipcAccummalted
	 *            (Array ipc Acumulado)
	 */
	@Transient
	public Double getValueIncreisedConcept(String ipcYearly, String ipcMonthly, Calendar calculationDate, RentableUnitContribution ruc, String ipcAccummalted, String minimumWage) {
		/**
		 * Se valida si el Concepto tiene incremento
		 */
		if (this.increased != null) {

			try {
				/**
				 * Se ejecuta incremento
				 */
				return this.executeScript(ruc, calculationDate, ipcYearly, ipcMonthly, ipcAccummalted, this.getIncreased().getExpression(), null, minimumWage);

			} catch (NullPointerException npex) {
				log(Level.INFO, "ERROR  OBTENIENDO VALOR DEL INCREMENTO: " + this.getId() + " HT: " + this.getProjectProperty().getId());
				npex.printStackTrace();
				return null;
			}
		}
		return null;
	}

	/**
	 * Metodo que Valida si una expression de incremento es correcta..
	 * 
	 * @param ipcYearly
	 * @param ipcMonthly
	 * @param calculationDate
	 * @param ruc
	 * @param sales
	 * @param expression
	 * @return
	 */
	@Transient
	public Boolean validateIncreisedConcept(String ipcYearly, String ipcMonthly, String ipcAccumalted, Calendar calculationDate, RentableUnitContribution ruc, Sales sales, String expression, String minimumWage) {

		log(Level.INFO, "***********VALIDANDO INCREMENTO**************************");
		try {
			/**
			 * Se ejecuta incremento
			 */
			Double increasedValue = this.executeScript(ruc, calculationDate, ipcYearly, ipcMonthly, ipcAccumalted, expression, null, minimumWage);
			/**
			 * Calculo de la formula incorrecta
			 */
			if (increasedValue == null) {
				log(Level.INFO, "ERROR  EJCURANDO INCREMENTO DEL CONCEPT  ");
				return false;
			}
			log(Level.INFO, "Valor de la operacion: " + increasedValue + "-Concept: " + this.id);

		} catch (NullPointerException npex) {
			log(Level.INFO, "ERROR  EJCURANDO INCREMENTO DEL CONCEPT : " + npex);
			npex.printStackTrace();
			return false;
		}

		return true;
	}

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "concept")
	@Audited(targetAuditMode = RelationTargetAuditMode.NOT_AUDITED)
	@NotAudited
	public List<InvoiceConcept> getInvoiceConcepts() {
		return this.invoiceConcepts;
	}

	public void setInvoiceConcepts(List<InvoiceConcept> invoiceConcepts) {
		this.invoiceConcepts = invoiceConcepts;
	}

	@Column(name = "expression", length = 20000)
	@Length(max = 20000)
	public String getExpression() {
		return this.expression;
	}

	public void setExpression(String expression) {
		this.expression = expression;
	}

	@Column(name = "priority", nullable = false)
	public int getPriority() {
		return this.priority;
	}

	public void setPriority(int priority) {
		this.priority = priority;
	}

	@Transient
	public Date getEndDate() {
		Date endDate = null;
		if (this != null && this.getStartDate() != null && this.getPeriodicity() != null && this.getPeriodicityType() != null && this.getPeriodicityType() != 0 && this.getNumberPeriods() != null) {

			Calendar calendar = Calendar.getInstance();
			calendar.setTime(this.getStartDate());

			switch (this.getPeriodicityType()) {
			case Concept.DAYS_PERIOD_TYPE:
				calendar.add(Calendar.DAY_OF_MONTH, (this.getPeriodicity().intValue() * this.getNumberPeriods()));
				break;

			case Concept.MONTHS_PERIOD_TYPE:
				calendar.add(Calendar.MONTH, (this.getPeriodicity().intValue() * this.getNumberPeriods()));
				break;
			case Concept.YEARS_PERIOD_TYPE:
				calendar.add(Calendar.YEAR, (this.getPeriodicity().intValue() * this.getNumberPeriods()));
				break;
			default:
				break;
			}
			/*
			 * La siguiente linea se pone en comentario, ya que causa mal
			 * funcionamiento del Cron Job, Los ciclos liquidables de un
			 * concepto en el cron job no disminuyen en un dia (1) y esto
			 * provoca que el ultimo periodo de un concepto no se liquide.
			 * Pendiente aclarar definicion funcional de la periodicidad de un
			 * concepto.
			 */
			// calendar.add(Calendar.DAY_OF_MONTH, -1);
			endDate = calendar.getTime();
		}
		return endDate;
	}

	@Transient
	public Date getEndDateView() {
		Date endDate = null;
		if (this != null && this.getStartDate() != null && this.getPeriodicity() != null && this.getPeriodicityType() != null && this.getPeriodicityType() != 0 && this.getNumberPeriods() != null) {

			Calendar calendar = Calendar.getInstance();
			calendar.setTime(this.getStartDate());

			switch (this.getPeriodicityType()) {
			case Concept.DAYS_PERIOD_TYPE:
				calendar.add(Calendar.DAY_OF_MONTH, (this.getPeriodicity().intValue() * this.getNumberPeriods()));
				break;

			case Concept.MONTHS_PERIOD_TYPE:
				calendar.add(Calendar.MONTH, (this.getPeriodicity().intValue() * this.getNumberPeriods()));
				break;
			case Concept.YEARS_PERIOD_TYPE:
				calendar.add(Calendar.YEAR, (this.getPeriodicity().intValue() * this.getNumberPeriods()));
				break;
			default:
				break;
			}

			calendar.add(Calendar.DAY_OF_MONTH, -1);
			endDate = calendar.getTime();
		}
		return endDate;
	}

	@ManyToOne(fetch = FetchType.LAZY)
	@JoinColumn(name = "contribution_module")
	@Audited(targetAuditMode = RelationTargetAuditMode.NOT_AUDITED)
	@NotAudited
	public ContributionModule getContributionModule() {
		return contributionModule;
	}

	public void setContributionModule(ContributionModule contributionModule) {

		this.contributionModule = contributionModule;
	}

	@OneToMany(fetch = FetchType.LAZY, mappedBy = "concept", cascade = CascadeType.ALL)
	@Audited(targetAuditMode = RelationTargetAuditMode.NOT_AUDITED)
	@NotAudited
	public List<ConceptRetentionRateAccount> getConceptRetentionRateAccounts() {

		return this.conceptRetentionRateAccounts;
	}

	public void setConceptRetentionRateAccounts(List<ConceptRetentionRateAccount> conceptRetentionRateAccounts) {
		this.conceptRetentionRateAccounts = conceptRetentionRateAccounts;
	}

	@Column(name = "seed")
	public boolean isSeed() {
		return seed;
	}

	public void setSeed(boolean seed) {
		this.seed = seed;
	}

	@Column(name = "dependent")
	public boolean isDependent() {
		return dependent;
	}

	public void setDependent(boolean dependent) {
		this.dependent = dependent;
	}

	@Column(name = "interest_arrears", nullable = false)
	public boolean isInterestArrears() {
		return this.interestArrears;
	}

	@Column(name = "cost_center")
	public String getCostCenter() {
		return this.costCenter;
	}

	public void setCostCenter(String costCenter) {
		try {
			//this.costCenter = Integer.parseInt(costCenter + "");
			this.costCenter = costCenter + "";
		} catch (Exception e) {
			this.costCenter = "0";
		}
	}

	@Column(name = "cost_center_type")
	public int getCostCenterType() {
		return this.costCenterType;
	}

	public void setCostCenterType(int costCenterType) {
		this.costCenterType = costCenterType;
		if (this.costCenterType != Concept.COST_CENTER_TYPE_CONCEPT) {
			this.costCenter = "0";
		}
	}

	public void setInterestArrears(boolean interestArrears) {
		this.interestArrears = interestArrears;
	}

	@Column(name = "automatic_extension", nullable = false)
	public boolean isAutomaticExtension() {
		return this.automaticExtension;
	}

	public void setAutomaticExtension(boolean automaticExtension) {
		this.automaticExtension = automaticExtension;
	}

	@Column(name = "immediate_payment_state", nullable = false)
	public int getImmediatePaymentState() {
		return immediatePaymentState;
	}

	public void setImmediatePaymentState(int immediatePaymentState) {
		this.immediatePaymentState = immediatePaymentState;
	}

	/**
	 * MÉTODO QUE BUSCA UNA CUENTA CONTABLE EN EL CONJUNTO DE CUENTAS DLE
	 * CONCEPTO
	 * 
	 * @param typeAccount
	 *            tipo de cuenta que se busca en el concepto
	 * @return
	 */
	@Transient
	public RetentionRateAccount searchAccount(int typeAccount) {
		for (ConceptRetentionRateAccount conceptRetentionRateAccount : conceptRetentionRateAccounts) {
			if (conceptRetentionRateAccount.getRetentionRateAccount().getRetentionRate().getId() == typeAccount) {
				return conceptRetentionRateAccount.getRetentionRateAccount();
			}
		}
		return null;
	}

	/**
	 * Método que actualiza o guarda una cuenta en el concepto según el tipo
	 * 
	 * @param typeAccount
	 *            tipo de cuenta que se va a adicionar
	 * @param account
	 *            cuanta que se adicona al concepto
	 */
	@Transient
	public void setAccount(int typeAccount, ConceptRetentionRateAccount account) {
		boolean flag = true;
		for (ConceptRetentionRateAccount conceptRetentionRateAccount : conceptRetentionRateAccounts) {
			if (conceptRetentionRateAccount.getRetentionRateAccount().getRetentionRate().getId() == typeAccount) {
				conceptRetentionRateAccount.setRetentionRateAccount(account.getRetentionRateAccount());
				flag = false;
				break;
			}
		}

		if (flag) {
			conceptRetentionRateAccounts.add(account);
		}
	}

	@Transient
	public void setRetention(ConceptRetentionRateAccount accountReceivable) {
		setAccount(accountReceivable.getRetentionRateAccount().getRetentionRate().getId(), accountReceivable);
	}

	@Transient
	public RetentionRateAccount getAccountReceivable() {
		return searchAccount(RetentionRate.RETENTION_RATE_ACCOUNTS_RECEIVABLE);
	}

	@Transient
	public void setAccountReceivable(ConceptRetentionRateAccount accountReceivable) {
		setAccount(RetentionRate.RETENTION_RATE_ACCOUNTS_RECEIVABLE, accountReceivable);
	}

	@Transient
	public RetentionRateAccount getAccountingAccountsRecover() {
		return this.searchAccount(RetentionRate.RETENTION_RATE_BANK_ACCOUNT);
	}

	@Transient
	public int getCostCenterTypeProject() {
		return COST_CENTER_TYPE_PROJECT;
	}

	@Transient
	public int getCostCenterTypeRentableunit() {
		return COST_CENTER_TYPE_RENTABLEUNIT;
	}

	@Transient
	public int getCostCenterTypeConcept() {
		return COST_CENTER_TYPE_CONCEPT;
	}

	@Transient
	public void setAccountingAccountsRecover(ConceptRetentionRateAccount accountBank) {
		setAccount(RetentionRate.RETENTION_RATE_BANK_ACCOUNT, accountBank);
	}

	@Transient
	public RetentionRateAccount getAccountingAccountsEarlyPayment() {
		return this.searchAccount(RetentionRate.RETENTION_RATE_DISCOUNT);
	}

	@Transient
	public void setAccountingAccountsEarlyPayment(ConceptRetentionRateAccount accountDiscount) {
		setAccount(RetentionRate.RETENTION_RATE_DISCOUNT, accountDiscount);
	}

	@Transient
	public RetentionRateAccount getAccountingCreditAccounts() {
		return this.searchAccount(RetentionRate.RETENTION_RATE_INCOME_ACCOUNT);
	}

	@Transient
	public void setAccountingCreditAccounts(ConceptRetentionRateAccount accountIncome) {
		setAccount(RetentionRate.RETENTION_RATE_INCOME_ACCOUNT, accountIncome);
	}

	@Transient
	public RetentionRateAccount getAccountingPenaltyPortafolio() {
		return this.searchAccount(RetentionRate.RETENTION_RATE_PENALTY_OF_PORTAFOLIO);
	}

	/**
	 * SUBCATEGORIA DE Cuentas De Orden Deudora - CDOD-
	 * 
	 */
	@Transient
	public RetentionRateAccount getAccountingCDOD_cuentasBancos() {
		return this.searchAccount(RetentionRate.RETENTION_RATE_SUBCATEGORY_CUENTAS_DE_BANCOS);
	}

	/**
	 * SUBCATEGORIA DE Cuentas De Orden Deudora - CDOD-
	 * 
	 */
	@Transient
	public void setAccountingAccountingCDOD_cuentasBancos(ConceptRetentionRateAccount accountIncome) {
		setAccount(RetentionRate.RETENTION_RATE_SUBCATEGORY_CUENTAS_DE_BANCOS, accountIncome);
	}

	/**
	 * SUBCATEGORIA DE Cuentas De Orden Deudora - CDOD-
	 * 
	 */
	@Transient
	public RetentionRateAccount getAccountingCDOD_cuentasIngresos() {
		return this.searchAccount(RetentionRate.RETENTION_RATE_SUBCATEGORY_CUENTAS_DE_INGRESOS);
	}

	/**
	 * SUBCATEGORIA DE Cuentas De Orden Deudora - CDOD-
	 * 
	 */
	@Transient
	public void setAccountingAccountingCDOD_cuentasIngresos(ConceptRetentionRateAccount accountIncome) {
		setAccount(RetentionRate.RETENTION_RATE_SUBCATEGORY_CUENTAS_DE_INGRESOS, accountIncome);
	}

	/**
	 * SUBCATEGORIA DE Cuentas De Orden Deudora - CDOD-
	 * 
	 */
	@Transient
	public RetentionRateAccount getAccountingCDOD_cuentasIVA() {
		return this.searchAccount(RetentionRate.RETENTION_RATE_SUBCATEGORY_CUENTAS_DE_IVA);
	}

	/**
	 * SUBCATEGORIA DE Cuentas De Orden Deudora - CDOD-
	 * 
	 */
	@Transient
	public void setAccountingAccountingCDOD_cuentasIVA(ConceptRetentionRateAccount accountIncome) {
		setAccount(RetentionRate.RETENTION_RATE_SUBCATEGORY_CUENTAS_DE_IVA, accountIncome);
	}

	/**
	 * SUBCATEGORIA DE Cuentas De Orden Deudora - CDOD-
	 * 
	 */
	@Transient
	public RetentionRateAccount getAccountingCDOD_cuentasXCobrar() {
		return this.searchAccount(RetentionRate.RETENTION_RATE_SUBCATEGORY_CUENTAS_POR_COBRAR);
	}

	/**
	 * SUBCATEGORIA DE Cuentas De Orden Deudora - CDOD-
	 * 
	 */
	@Transient
	public void setAccountingAccountingCDOD_cuentasXCobrar(ConceptRetentionRateAccount accountIncome) {
		setAccount(RetentionRate.RETENTION_RATE_SUBCATEGORY_CUENTAS_POR_COBRAR, accountIncome);
	}

	/**
	 * SUBCATEGORIA DE Cuentas De Orden Deudora - CDOD-
	 * 
	 */
	@Transient
	public RetentionRateAccount getAccountingCDOD_cuentasDeudoraControlContario() {
		return this.searchAccount(RetentionRate.RETENTION_RATE_SUBCATEGORY_DEUDORAS_CONTROL_CONTRARIO);
	}

	/**
	 * SUBCATEGORIA DE Cuentas De Orden Deudora - CDOD-
	 * 
	 */
	@Transient
	public void setAccountingAccountingCDOD_cuentasDeudoraControlContario(ConceptRetentionRateAccount accountIncome) {
		setAccount(RetentionRate.RETENTION_RATE_SUBCATEGORY_DEUDORAS_CONTROL_CONTRARIO, accountIncome);
	}

	/**
	 * SUBCATEGORIA DE Cuentas De Orden Deudora - CDOD-
	 * 
	 */
	@Transient
	public RetentionRateAccount getAccountingCDOD_cuentasDeudoraControlInteresVencida() {
		return this.searchAccount(RetentionRate.RETENTION_RATE_SUBCATEGORY_DEUDORAS_CONTROL_INTERESES_DEUDAS_VENCIDAS);
	}

	/**
	 * SUBCATEGORIA DE Cuentas De Orden Deudora - CDOD-
	 * 
	 */
	@Transient
	public void setAccountingAccountingCDOD_cuentasDeudoraInteresVencida(ConceptRetentionRateAccount accountIncome) {
		setAccount(RetentionRate.RETENTION_RATE_SUBCATEGORY_DEUDORAS_CONTROL_INTERESES_DEUDAS_VENCIDAS, accountIncome);
	}

	/**
	 * SUBCATEGORIA DE Cuentas De Orden Deudora - CDOD-
	 * 
	 */
	@Transient
	public RetentionRateAccount getAccountingCDOD_cuentasOtrosIngresos() {
		return this.searchAccount(RetentionRate.RETENTION_RATE_SUBCATEGORY_OTROSINGRESOS);
	}

	/**
	 * SUBCATEGORIA DE Cuentas De Orden Deudora - CDOD-
	 * 
	 */
	@Transient
	public void setAccountingAccountingCDOD_cuentasOtrosIngresos(ConceptRetentionRateAccount accountIncome) {
		setAccount(RetentionRate.RETENTION_RATE_SUBCATEGORY_OTROSINGRESOS, accountIncome);
	}

	/**
	 * SUBCATEGORIA DE Cuentas De Orden Deudora - CDOD-
	 * 
	 */
	@Transient
	public RetentionRateAccount getAccountingCDOD_cuentasReteFuente() {
		return this.searchAccount(RetentionRate.RETENTION_RATE_SUBCATEGORY_RETEFUENTE);
	}

	/**
	 * SUBCATEGORIA DE Cuentas De Orden Deudora - CDOD-
	 * 
	 */
	@Transient
	public void setAccountingAccountingCDOD_cuentasReteFuente(ConceptRetentionRateAccount accountIncome) {
		setAccount(RetentionRate.RETENTION_RATE_SUBCATEGORY_RETEFUENTE, accountIncome);
	}

	/**
	 * SUBCATEGORIA DE Cuentas De Orden Deudora - CDOD-
	 * 
	 */
	@Transient
	public RetentionRateAccount getAccountingCDOD_cuentasReteICA() {
		return this.searchAccount(RetentionRate.RETENTION_RATE_SUBCATEGORY_RETEICA);
	}

	/**
	 * SUBCATEGORIA DE Cuentas De Orden Deudora - CDOD-
	 * 
	 */
	@Transient
	public void setAccountingAccountingCDOD_cuentasReteICA(ConceptRetentionRateAccount accountIncome) {
		setAccount(RetentionRate.RETENTION_RATE_SUBCATEGORY_RETEICA, accountIncome);
	}

	/**
	 * SUBCATEGORIA DE Cuentas De Orden Deudora - CDOD-
	 * 
	 */
	@Transient
	public RetentionRateAccount getAccountingCDOD_cuentasReteIVA() {
		return this.searchAccount(RetentionRate.RETENTION_RATE_SUBCATEGORY_RETEIVA);
	}

	/**
	 * SUBCATEGORIA DE Cuentas De Orden Deudora - CDOD-
	 * 
	 */
	@Transient
	public void setAccountingAccountingCDOD_cuentasReteIVA(ConceptRetentionRateAccount accountIncome) {
		setAccount(RetentionRate.RETENTION_RATE_SUBCATEGORY_RETEIVA, accountIncome);
	}

	@Transient
	public String getFormatFixedValue() {
		DecimalFormat formato = new DecimalFormat("#.##");
		if (getFixedValue() != null) {
			String temp = formato.format(getFixedValue());
			return temp;
		}
		return null;
	}

	@Transient
	public void setFormatFixedValue(String fixedvalue) {
		Double d = null;
		try {
			d = Double.parseDouble(fixedvalue);
			setFixedValue(d);
		} catch (Exception e) {
			setFixedValue(d);
		}
	}

	@Transient
	public void cleanAccount(int id) {
		int i = 0;
		try {
			for (ConceptRetentionRateAccount conceptRetentionRateAccount : conceptRetentionRateAccounts) {

				if (conceptRetentionRateAccount.getRetentionRateAccount().getRetentionRate().getId() == id) {
					RetentionToDelete.add(conceptRetentionRateAccount);
					conceptRetentionRateAccounts.remove(i);
					break;
				}
				i++;
			}
		} catch (Exception e) {
			log(Level.INFO, "------------------------------------------------------------------- ");
			e.printStackTrace();

		}

	}

	public static List<ConceptRetentionRateAccount> getRetentionToDelete() {
		return RetentionToDelete;
	}

	@Column(name = "bulk_load")
	public boolean getBulkLoad() {
		return this.bulkLoad;
	}

	public void setBulkLoad(boolean bulkname) {
		this.bulkLoad = bulkname;
	}

	@Column(name = "last_modification")
	public Date getLastModification() {
		return lastModification;
	}

	public void setLastModification(Date lastModification) {
		this.lastModification = lastModification;
	}

	@Column(name = "discount_mounths")
	public Integer getDiscountMounths() {
		if (discountMounths == null)
			discountMounths = 0;
		return discountMounths;
	}

	public void setDiscountMounths(Integer mounthsDiscount) {
		this.discountMounths = mounthsDiscount;
	}

	@Column(name = "show__billed_period")
	public boolean isShowBilledPeriod() {
		return showBilledPeriod;
	}

	public void setShowBilledPeriod(boolean showBilledPeriod) {
		this.showBilledPeriod = showBilledPeriod;
	}

	/**
	 * This function prints a message in log file.
	 * 
	 * @param level
	 *            Level object
	 * @param message
	 *            String message to be printed
	 */
	@Transient
	private void log(Level level, Object message) {
		StringBuilder init = new StringBuilder();
		init.append(" ");
		int minLong = Concept.class.getSimpleName().length() + level.getName().toString().length();
		if (level == Level.WARNING) {
			minLong--;
		}
		while (minLong + init.length() < 40) {
			init.append("#");
		}
		init.append(" ");
		init.append(message.toString());
		Logger.getLogger(Concept.class.getSimpleName()).log(level, init.toString());
	}

}